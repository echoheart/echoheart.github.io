---
layout:     post
title:      HTTP请求流程
subtitle:   HTTP请求流程
date:       2019-08-19
author:     limantang
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 浏览器
---

# HTTP请求流程

HTTP是一种允许浏览器向服务器获取资源的协议, 通常由浏览器发起请求, 用来获取不同类型的文件, 是Web的基础, HTTP协议建立在TCP基础之上

HTTP是浏览器使用最广的协议

如果在地址栏输入http://www.echoheart.cn浏览器会完成哪些动作呢

1. 构建请求

   首先浏览器构建请求行信息, 构建好后,浏览器准备发起网络请求

   ```tsx
   GET /index.html HTTP1.1
   ```

2. 查找缓存

   发起真正请求之前, 浏览器会先在浏览器缓存中查询是否有要请求的文件

   当浏览器发现请求的资源已经在浏览器缓存中存有副本, 浏览器会拦截请求, 返回资源的副本, 并且直接结束请求, 好处有二

   - 缓解服务器压力, 提升性能
   - 对于网站来说, 缓存是实现快速资源加载的重要组成部分

   如果缓存查找失败, 就会进入网络请求流程了

3. 准备IP地址和端口

   浏览器使用HTTP作为应用层协议, 用来封装请求的文本信息, TCP/IP作为传输层协议将它通过网络传输, 所以在HTTP开始工作之前, 浏览器需要通过TCP/IP服务器建立连接

   - HTTP网络请求的第一步: 浏览器和服务器建立TCP连接
   - 建立连接所需要的信息: IP地址和端口号
   - 根据URL地址来获取IP地址和端口号

   如何根据URL地址获取IP和端口号呢

   使用DNS(域名系统)来作为域名和IP的映射系统

   所以最终的流程就是: 第一步浏览器请求DNS返回域名对应的IP, 浏览器也提供DNS缓存服务, 拿到IP之后就是获取端口号, 通常情况下, 如果没有特别指出, HTTP协议默认为80

4. 等待TCP队列

   就算有了IP地址和端口号还是不能马上建立TCP连接

   Chrome有个机制同一个域名同时最多只能建立6个TCP连接, 如果同一个域名同时有10个请求发生, 其中有四个会进入排队等待状态, 如果请求数量小于6那么就会直接进入建立TCP连接

5. 建立TCP连接

   具体连接流程看上一篇文章

6. 发送HTTP请求

   浏览器会发送请求行包括**请求方法**, **请求URI**, **HTTP版本协议**

   最常用的请求方法就是GET

   另外一个常用的请求方法是POST, 用于发送一些数据给服务器, 发送给服务器的数据被放在请求体里来发送

   在浏览器发送请求行命令后, 还要以请求头的形式发送一些其他信息, 把浏览器的一些基础信息高速服务器吗包括了浏览器所使用的操作系统, 浏览器内核, 以及当前请求的域名信息, 浏览器端的Cookie信息

**服务器处理HTTP请求**

1. 服务器处理结束后, 就会返回数据给浏览器

   - 服务器会返回**响应行**, 包括协议版本和状态码
     - 最常用的状态码是200, 表示处理成功
     - 如果没有找到页面则会返回404

   如浏览器会随同请求发送请求头一样, 服务器也会随同响应发送**响应头**,响应头包含了服务器自身的一些信息, 比如服务器生成返回数据的时间, 返回数据的类型(JSON, HTML, 流媒体等类型), 以及服务器要在客户端保存的Cookie信息

   在发送完响应头后, 服务器就可以继续发送**响应体**的数据, 通常响应体就包含了HTML的实际内容

2. 断开连接

   通常情况下, 一旦服务器向客户端反悔了请求数据, 它就会关闭TCP连接, 不过如果浏览器或者服务器在其头部信息加入了

   ```tsx
   Connection: Keep-Alive
   ```

   那么TCP连接在发送之后仍然保持打开状态, 这样浏览器就可以继续通过同一个TCP连接发送请求, **保持TCP连接省去了下次请求时建立连接的时间, 提升资源加载速度**

3. 重定向

   如果你在浏览器输入的是echoheart.cn, 你会发现最终打开的页面是http://www.echoheart.cn

   这是因为**重定向操作**

   有的网站服务器支持这种重定向操作, 有的则不支持

**为什么很多网站第二次打开速度会很快**

从上面的内容大概可以看出为什么第二次打开速度回更快

- DNS缓存
- 页面资源缓存
  - 服务器返回HTTP响应头给浏览器, 浏览器通过响应头中的Cache-Control字段来设置是否缓存该资源
  - 如果缓存还未过期, 浏览器再次请求该资源时, 就会直接返回缓存的资源
  - 如果缓存过期了. 浏览器会发起网络请求, 并且在HTTP请求头中带上If-None-Match: XXXXX
  - 服务器收到请求后根据If-None-Match来判断资源是否有更新
    - 如果没有更新返回304, 意味缓存可以继续使用
    - 否则就返回最新的资源给浏览器

**登录状态是如何保持的**

简单一句话: 通过cookie验证来确认登录状态


